#!/usr/bin/env python

import os
import re
import csv
import sys
import signal
import argparse


# without this, we may encounter fields larger than can be read
csv.field_size_limit(sys.maxsize)


class XLSXReader(object):

    headers = None

    def __init__(self, fileobj):
        from openpyxl import load_workbook
        self.wb = load_workbook(fileobj, read_only=True, data_only=True)
        self.ws = self.wb.active

    def __iter__(self):

        for row in self.ws.rows:

            if self.headers is None:
                self.headers = []
                for cell in row:
                    self.headers.append(cell.value)
                continue

            values = [c.value for c in row]
            values = values[:len(self.headers)]
            while len(values) < len(self.headers):
                values.append(None)

            yield dict(zip(self.headers, values))


class Cut(object):

    def __init__(self, name=None, start=None, end=None, format=None):
        self.name = name
        self.start = start
        self.end = end
        self.format = format

    def __repr__(self):
        return "Cut(name={!r}, start={!r}, end={!r}, format={!r})".format(
            self.name,
            self.start,
            self.end,
            self.format,
        )

    def parse(self, value):

        # consider the empty string to be null basically and attempt no further
        # transformations
        if value == "":
            return value

        if self.format is not None:

            # signed overpunch
            format_match = re.search(r'^s9[(](\d+)[)](v9[(](\d+)[)])?$', self.format)
            if format_match is not None:

                if format_match.groups()[1] is None:
                    decimals = 0
                else:
                    decimals = int(format_match.groups()[2])

                import overpunch
                value = overpunch.extract(value, decimals=decimals)

                value = "{}".format(value)

            # implicit decimal point
            format_match = re.search(r'^9[(](\d+)[)]v9[(](\d+)[)]$', self.format)
            if format_match is not None:

                decimals = int(format_match.groups()[1])
                value = value[:-decimals] + "." + value[-decimals:]

            # a different implied decimal point format
            format_match = re.search(r'^N\s?[(](\d+).(\d+)[)]$', self.format)
            if format_match is not None:

                decimals = int(format_match.groups()[1])
                value = value[:-decimals] + "." + value[-decimals:]

        return value


class Converter(object):

    def __init__(self, cuts_path):
        self.cuts = []

        if cuts_path.endswith(".csv") or cuts_path.endswith(".xlsx"):
            if cuts_path.endswith(".csv"):
                cfp = open(cuts_path, "r")
                reader = csv.DictReader(cfp)
            elif cuts_path.endswith(".xlsx"):
                cfp = open(cuts_path, "rb")
                reader = XLSXReader(cfp)

            name_key = None
            end_key = None
            format_key = None

            for row in reader:
                if name_key is None:

                    name_options = [
                        "name",
                        "Field Name",
                    ]

                    name_key = self._get_key_for_name(
                        row,
                        "name",
                        name_options,
                    )

                if end_key is None:

                    end_options = [
                        "end",
                        "End",
                        "To POS",
                        "Field Location To",
                    ]

                    end_key = self._get_key_for_name(
                        row,
                        "end",
                        end_options,
                    )

                if format_key is None:

                    format_options = [
                        "format",
                        "Format",
                        "Type",
                        "Field Type",
                        "Field Format",
                    ]

                    format_key = self._get_key_for_name(
                        row,
                        "format",
                        format_options,
                        missing_ok=True,
                    )

                name = row.get(name_key)

                if not name:
                    continue

                end = int(row.get(end_key))
                format = row.get(format_key)

                cut = Cut(name=name, end=end, format=format)
                self.cuts.append(cut)

        else:
            for line in cfp:
                line = line.strip()

                try:
                    name, end = re.split(r'\s+', line)

                    cut = Cut(name=name, end=int(end))
                    self.cuts.append(cut)

                except TypeError:
                    cut = Cut(name=line, end=None)
                    self.cuts.append(cut)
                except ValueError:
                    cut = Cut(name=line, end=None)
                    self.cuts.append(cut)

    def _get_key_for_name(self, row, name, options, missing_ok=False):
        for option in options:
            if option in row:
                return option

        if not missing_ok:
            raise ValueError("Unable to determine key for '{}'".format(name))

    @property
    def fields(self):
        return [v.name for v in self.cuts]

    def parse(self, fp):
        if fp == "-":
            fp = sys.stdin
        elif isinstance(fp, str):
            fp = open(fp, "r")
        elif isinstance(fp, int):
            fp = os.fdopen(fp, "r")

        for line in fp:
            yield self.split(line)

    def split(self, line):
        values = []
        start = 0
        for cut in self.cuts:

            end = cut.end

            if end is None:
                value = line[start:].strip()
            else:
                value = line[start:end].strip()

            value = cut.parse(value)
            values.append(value)

            start = end

        return values


if __name__ == "__main__":

    # ignore pipe errors using head, etc
    signal.signal(signal.SIGPIPE, signal.SIG_DFL) 

    parser = argparse.ArgumentParser()
    parser.add_argument("cuts", help="path to the cuts file")
    parser.add_argument("files", nargs="*", help="files to process")

    args = parser.parse_args()

    if not args.files:
        args.files = ["-"]

    converter = Converter(args.cuts)

    writer = csv.writer(sys.stdout)
    writer.writerow(converter.fields)
    for file in args.files:
        for rec in converter.parse(file):
            writer.writerow(rec)

